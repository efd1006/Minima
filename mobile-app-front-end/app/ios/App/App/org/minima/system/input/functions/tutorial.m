//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./org/minima/system/input/functions/tutorial.java
//

#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "org/minima/system/input/CommandFunction.h"
#include "org/minima/system/input/functions/tutorial.h"
#include "org/minima/utils/ResponseStream.h"
#include "org/minima/utils/json/JSONObject.h"

NSString *OrgMinimaSystemInputFunctionstutorial_TUTORIAL_TEXT = @"\nMinima transactions are a series of inputs, a series of outputs and a variable list known as the state, which you can access from the script with STATE. The state can be accessed by all the input scripts, and is stored in the MMR database, so can be accessed by PREVSTATE in the next transaction the outputs are added to, as inputs. \n\nThe sum of the outputs must be less than or equal to the sum of the inputs, for every tokenid used. The difference in raw minima is the Burn. \n\nA Minima input script returns TRUE or FALSE. The default is return FALSE, so all inputs must explicitly RETURN TRUE for the transaction to be valid.\n\nA transaction can be signed, in full, by one or more public keys.\n\nMinima allows input scripts to have perfect knowledge of the entire transaction. How many, token type, amount and the address of all inputs and outputs are available. An input knows it's own script ( @SCRIPT ) and can ensure an output of a similar address exists in the outputs. \n\nA script can run for 512 instructions. An instruction is 1 operation or function.\n\nThe addition of the state variables in the MMR Proof DB, allow for complex scripts with knowledge of their past to be created. A simple state mechanic for transactional history rather than a global state for ALL transactions.\n\nMinima tracks all coins that are to an address you possess and all coins that have a public key or address you possess in the STATE or PREVSTATE.\n\nMinima transactions are scriptable Logic Gates, with analogue inputs and outputs, a simple yet powerful control language, and a previous history state mechanic.\n\nI think of them as Script Gates.\n\nGrammar\n-------\n\nADDRESS     ::= SHA3 ( BLOCK )\nBLOCK       ::= STATEMENT_1 STATEMENT_2 ... STATEMENT_n\nSTATEMENT   ::= LET VARIABLE = EXPRESSION |\n                LET ( EXPRESSION_1 EXPRESSION_2 ... EXPRESSION_n ) = EXPRESSION |\n                IF EXPRESSION THEN BLOCK [ELSEIF EXPRESSION THEN BLOCK]* [ELSE BLOCK] ENDIF | \n                WHILE EXPRESSION DO BLOCK ENDWHILE |\n                EXEC EXPRESSION |\n                MAST EXPRESSION |\n                ASSERT EXPRESSION |\n                RETURN EXPRESSION\nEXPRESSION  ::= RELATION AND RELATION  | RELATION OR RELATION  |  \n                RELATION XOR RELATION  | RELATION NAND RELATION | \n                RELATION NOR RELATION  |  RELATION NXOR RELATION | RELATION\nRELATION    ::= LOGIC EQ LOGIC  | LOGIC NEQ LOGIC  | \n                LOGIC GT LOGIC  | LOGIC GTE LOGIC  | \n                LOGIC LT LOGIC  | LOGIC LTE LOGIC  | LOGIC\nLOGIC       ::= LOGIC & OPERATION | LOGIC | OPERATION | \n                LOGIC ^ OPERATION | OPERATION\nOPERATION   ::= OPERATION + MULDIV | OPERATION - MULDIV | \n                OPERATION % MULDIV | \n                OPERATION << MULDIV | OPERATION >> MULDIV | MULDIV\nMULDIV      ::= MULDIV * PRIME | MULDIV / PRIME | PRIME\nPRIME       ::= NOT PRIME |  NEG PRIME | BASEUNIT\nBASEUNIT    ::= VARIABLE | VALUE | GLOBAL | FUNCTION | ( EXPRESSION )\nVARIABLE    ::= ^[a-z]{1,16}$\nVALUE       ::= NUMBER | BYTE | HEX | SCRIPT | BINARY\nNUMBER      ::= ^-?\\\\d*(\\\\.\\\\d+)?$\nBYTE        ::= [0-255]\nHEX         ::= 0x[0-9A-F]{2}*\nSCRIPT      ::= [ ASCII ]\nBINARY      ::= TRUE | FALSE\nFALSE       ::= 0\nTRUE        ::= NOT FALSE\nGLOBAL      ::= @BLKNUM | @INPUT | @INBLKNUM | @BLKDIFF\n      \t        @AMOUNT | @ADDRESS | @TOKENID | @COINID |\n                @SCRIPT | @TOTIN | @TOTOUT\nFUNCTION    ::= FUNC ( EXPRESSION_1 EXPRESSION_2 .. EXPRESSION_n ) \nFUNC        ::= HEXCAT | STRCAT | LEN | REV | SUBSET | RPLVAR | GET |\n                ASCII | BOOL | HEX | NUMBER | SCRIPT |\n                ABS | CEIL | FLOOR | MIN | MAX | INC | DEC | SIGDIG | POW |\n                BITSET | BITGET | PROOF | SHA3 | SHA2 |\n                SIGNEDBY | MULTISIG | CHECKSIG |\n                GETOUTADDR | GETOUTAMT | GETOUTTOK | VERIFYOUT |\n                GETINADDR | GETINAMT | GETINTOK | GETINID | VERIFYIN |\n                STATE | PREVSTATE | SAMESTATE | DYNSTATE\n\nGlobals\n-------\n\n@BLKNUM      : Block number this transaction is in\n@INBLKNUM    : Block number when this output was created\n@BLKDIFF     : Difference between BLKNUM and INBLKNUM\n@INPUT       : Input number in the transaction\n@AMOUNT      : Amount of this input\n@ADDRESS     : Address of this input\n@TOKENID     : TokenID of this input\n@COINID      : CoinID of this input\n@SCRIPT      : Script for this input\n@TOKENSCRIPT : Script for this input\n@TOTIN       : Total number of inputs for this transaction\n@TOTOUT      : Total number of outputs for this transaction\n\nFunctions\n---------\n\nHEXCAT ( HEX_1 HEX_2 ... HEX_n )\nConcatenate the values. All values are treated as HEX values \n\nSTRCAT ( SCRIPT_1 SCRIPT_2 ... SCRIPT_n )\nConcatenate the values. All values are treated as SCRIPT values. \nA space is added between each and then the script is CLEANED. \n\nLEN ( HEX )\nLength of the data\n\nREV ( HEX )\nReverse the data\n\nSUBSET ( HEX NUMBER NUMBER )\nReturn the HEX subset of the data - start - length\n\nRPLVAR ( SCRIPT SCRIPT SCRIPT ) \nIn a script, replace a variable definition with the following Expression. Can be used with @SCRIPT for recursive covenants.\n\nGET ( NUMBER NUMBER .. NUMBER )\nReturn the array value set with LET ( EXPRESSION EXPRESSION .. EXPRESSION )  \n\nASCII ( HEX )\nConvert the HEX value of a script value to a script\n\nBOOL ( VALUE )\nConvert to TRUE or FALSE value\n\nHEX ( SCRIPT )\nConvert SCRIPT to HEX\n\nNUMBER ( HEX )\nConvert HEX to NUMBER\n\nSCRIPT ( HEX ) \nConvert a HEX value to SCRIPT\n\nABS ( NUMBER )\nReturn the absolute value of a number\n\nCEIL ( NUMBER )\nReturn the number rounded up\n\nFLOOR ( NUMBER ) \nReturn the number rounded down\n\nMIN ( NUMBER NUMBER )\nReturn the minimum value of the 2 numbers\n\nMAX ( NUMBER NUMBER )\nReturn the maximum value of the 2 numbers\n\nINC ( NUMBER )\nIncrement a number\n\nDEC ( NUMBER )\nDecrement a number\n\nPOW ( NUMBER NUMBER )\nReturns the power of N of a number. N must be a whole number.\n\nSIGDIG ( NUMBER NUMBER )\nSet the significant digits of the number\n\nBITSET ( HEX NUMBER BINARY )\nSet the value of the BIT at that Position to 0 or 1\n\nBITGET ( HEX NUMBER ) \nGet the BINARY value of the bit at the position.\n\nCHAINSHA ( HEX HEX ) \nRecursively SHA3 hash the first HEX value with the merkle proof provided in the second. Returns the final result that can be checked in script. Use the 'chainsha' function in Minima to construct Hash Trees proofs for MAST and Signature Public Keys.   \n\nSHA3 ( NUMBER HEX ) \nReturns the SHA3 value of bitlength NUMBER of the HEX value. The SHA3 bitlength can be 160, 256 or 512.\n\nSHA2 ( HEX ) \nReturns the SHA2 value of the HEX value. 256 bits.\n\nSIGNEDBY ( HEX )\nReturns true if the transaction is signed by this public key\n\nMULTISIG ( BYTE HEX1 HEX2 .. HEXn )\nReturns true if the transaction is signed by N of the public keys\n\nCHECKSIG ( HEX HEX HEX)\nCheck public key, data and signature \n\nGETOUTADDR ( BYTE ) \nReturn the HEX address of the specified output\n\nGETOUTAMT ( BYTE ) \nReturn the amount of the specified output \n\nGETOUTTOK ( BYTE ) \nReturn the token id of the specified output\n\nVERIFYOUT ( BYTE HEX NUMBER HEX [NUMBER])\nVerify the specified output has the specified address, amount and tokenid. Optional 4th parameter relates to AMOUNT. -1 LTE, 0 EQ, 1 GTE. Default EQ.\n\nGETINADDR ( BYTE ) \nReturn the HEX address of the specified input\n\nGETINAMT ( BYTE ) \nReturn the amount of the specified input\n\nGETINTOK ( BYTE ) \nReturn the token id of the specified input\n\nVERIFYIN ( BYTE HEX NUMBER HEX [NUMBER])\nVerify the specified input has the specified address, amount and tokenid. Optional 4th parameter relates to AMOUNT. -1 LTE, 0 EQ, 1 GTE. Default EQ.\n\nSTATE ( BYTE )\nReturn the state value for the given number\n\nPREVSTATE ( BYTE )\nReturn the state value stored in the MMR data in the initial transaction this input was created. Allows for a state to be maintained from 1 spend to the next\n\nSAMESTATE ( BYTE [BYTE] )\nReturn TRUE if the previous state and current state are the same. If 2 parameters are set then checks all the values inbetween the 2 values inclusively\n\nDYNSTATE ( BYTE EXPRESSION )\nDynamically set the state value. You can only use this ONCE per state per transaction. MUST be used before STATE or SAMESTATE.\n\nExamples\n--------\n\nLET thing = 23\nLET ( 12 2 ) = 45.345\nLET ( 0 0 1 ) = 0xFF\nLET ( 0xFF ( thing + 1 ) ) = [ RETURN TRUE ]\n\n--\n\nRETURN SIGNEDBY ( 0x12345.. )\n\n--\n\nIF SIGNEDBY ( 0x123456.. ) AND SIGNEDBY ( 0x987654.. ) THEN\n   RETURN TRUE\nELSE IF @BLKNUM GT 198765 AND SIGNEDBY ( 0x12345.. ) THEN\n   RETURN TRUE\nENDIF\n\n--\n\nLET x = STATE ( 23 )\nLET shax = SHA3 ( x )\nIF shax EQ 0x6785456.. AND SIGNEDBY ( 0x12345.. ) THEN \n  RETURN TRUE \nENDIF\n\n--\n\nEXEC [ RETURN TRUE ]\n\n--\n\nMAST 0xA6657D2133E29B0A343871CAE44224BBA6BB87A972A5247A38A45D3D2065F7E4\n\n--\n\nLET old = [ LET add = 0xFFEEDDFFEEDD ]\nLET new = RPLVAR ( old [ add ] [ 0xEE ]] )\n\n--\n\nASSERT STATE ( 0 ) EQ INC ( PREVSTATE ( 0 ) )\n\n--\n";

@implementation OrgMinimaSystemInputFunctionstutorial

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OrgMinimaSystemInputFunctionstutorial_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)doFunctionWithNSStringArray:(IOSObjectArray *)zInput {
  (void) [((OrgMinimaUtilsJsonJSONObject *) nil_chk([((OrgMinimaUtilsResponseStream *) nil_chk([self getResponseStream])) getDataJSON])) putWithId:@"Tutorial" withId:OrgMinimaSystemInputFunctionstutorial_TUTORIAL_TEXT];
  [((OrgMinimaUtilsResponseStream *) nil_chk([self getResponseStream])) endStatusWithBoolean:true withNSString:@""];
}

- (OrgMinimaSystemInputCommandFunction *)getNewFunction {
  return new_OrgMinimaSystemInputFunctionstutorial_init();
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "LOrgMinimaSystemInputCommandFunction;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(doFunctionWithNSStringArray:);
  methods[2].selector = @selector(getNewFunction);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TUTORIAL_TEXT", "LNSString;", .constantValue.asLong = 0, 0x9, -1, 3, -1, -1 },
  };
  static const void *ptrTable[] = { "doFunction", "[LNSString;", "LJavaLangException;", &OrgMinimaSystemInputFunctionstutorial_TUTORIAL_TEXT };
  static const J2ObjcClassInfo _OrgMinimaSystemInputFunctionstutorial = { "tutorial", "org.minima.system.input.functions", ptrTable, methods, fields, 7, 0x1, 3, 1, -1, -1, -1, -1, -1 };
  return &_OrgMinimaSystemInputFunctionstutorial;
}

@end

void OrgMinimaSystemInputFunctionstutorial_init(OrgMinimaSystemInputFunctionstutorial *self) {
  OrgMinimaSystemInputCommandFunction_initWithNSString_(self, @"tutorial");
  [self setHelpWithNSString:@"" withNSString:@"Explain Minima and go through Scripting" withNSString:@""];
}

OrgMinimaSystemInputFunctionstutorial *new_OrgMinimaSystemInputFunctionstutorial_init() {
  J2OBJC_NEW_IMPL(OrgMinimaSystemInputFunctionstutorial, init)
}

OrgMinimaSystemInputFunctionstutorial *create_OrgMinimaSystemInputFunctionstutorial_init() {
  J2OBJC_CREATE_IMPL(OrgMinimaSystemInputFunctionstutorial, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgMinimaSystemInputFunctionstutorial)

J2OBJC_NAME_MAPPING(OrgMinimaSystemInputFunctionstutorial, "org.minima.system.input.functions", "OrgMinimaSystemInputFunctions")
